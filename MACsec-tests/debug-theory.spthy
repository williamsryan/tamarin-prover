theory MACsec_Debug
begin

section{* Tester for MACsec stuff. *}

/*
 *
 * Protocol:	MACsec
 *
 * Based on:    Component-Based Formal Analysis of 5G-AKA:
 *              Channel Assumptions and Session Confusion
 *
 * Channels:    TODO
 *
 * Functions:   TODO
 *
 * Modeler: 	Ryan Williams
 * Date: 	    May 2023
 *
 * Status: 	    DEVELOPMENTAL
 *
 */

 builtins:
    multiset,
    symmetric-encryption

 functions:
    KDF/3,  // KDF function.
    MAC/2   // MAC function.


 // Initialisation rule.
 rule preconfigure:
    let
    PSK = ~CAK
    ICK = KDF('0', 'ick', ~CAK)
    in
    [ Fr(~CAK) ]
    --[ Preconfigure(~CAK) ]->
    [ !Cak($A, PSK), !Cak($B, PSK), !Ick($A, ICK), !Ick($B, ICK) ]

 rule nonce_distribution:
    let
    nonce = ~nonce
    ntag = MAC(~nonce, ICK) // Verify this later.
    in
    [ Fr(~nonce), !Cak($A, PSK), !Cak($B, PSK), !Ick($A, ICK), !Ick($B, ICK) ]
    -->
    [ Asak(KDF(~nonce, 'sak', ~CAK)), Out(ntag), Out(~nonce) ]

 rule sak_derivation:
   // Bob runs MAC function on nonce using ICK.
   let
   ntag_prime = MAC(~nonce, ICK)
   in
   [ Asak(KDF(~nonce, 'sak', ~CAK)), In(ntag), In(~nonce) ]
   -->
   [ !Bsak(KDF(~nonce, 'sak', ~CAK)) ]

 rule sec_send:
   // Bob sends encoded message back to Alice.
   let
   m = ~m
   in
   [ Fr(~m), !Bsak(KDF(~nonce, 'sak', ~CAK)) ]
   -->
   [ Send($B, $A, senc(Bsak, m)), Out(senc(Bsak, m)) ]
   //[ senc(!Bsak, m), Out(senc(!Bsak, m))]

 rule sec_recv:
   // Alice reads encoded message from Bob.
   [ !Asak(KDF(~nonce, 'sak', ~CAK)), In(m) ]
   -->
   [ Receive($B, $A, sdec(Asak, m)) ]

 // Adversary rules.
 rule reveal_session_a:
   [ !Asak(KDF(~nonce, 'sak', ~CAK)) ]
   --[ SessionRevealA(sak) ]->
   [ Out(Asak) ]

 rule reveal_session_b:
   [ !Bsak(KDF(~nonce, 'sak', ~CAK)) ]
   --[ SessionRevealB(sak) ]->
   [ Out(Bsak) ]

//  rule reveal_cak:
//    [  ]

 // Key distribution rule.
//  rule ks_sak_init:
//     [ Anonce(Fr(~nonce)) ]
//     -->
//     [ ASAK(KDF(~nonce, "sak", ~CAK)), Out(~nonce) ]

//  rule ks_sak_init_reply:
//     [ Bnonce(In(~nonce)) ]
//     -->
//     [ BSAK(KDF(~nonce, "sak", ~CAK)), Out(~nonce) ]

//  rule send_sec:
//     let
//     m = "hello",
//     enc_txt = senc(ASAK, m)
//     in
//     [ Send(A, B, enc_txt) ]
//     -->
//     [ Out(enc_txt) ]

 // This is a standard, secure channel abstraction, as previously used in work 
 // by Basin, Radomirovic, and Schmid: Modeling Human Errors in Security Protocols
 // (CSF 2016)
 // Normal Send Secure and Receive Secure rules.
 // Model: "normal channels"
//  rule send_secure:
//     [F_SndS(<channelname, SendType, ReceiveType>, A, B, m)]
//     --[SendSecure(channelname, A, B, m)]->
//     [Sec(<channelname, SendType, ReceiveType>, A, B, m)]

//  rule receive_secure:
//     [Sec(<channelname, SendType, ReceiveType>, A, B, m)]
//     --[ReceiveSecure(channelname, A, B, m)]->
//     [F_RcvS(<channelname, SendType, ReceiveType>, A, B, m)]

 // Holds.
//  lemma rand_autn_src [sources]:
//     " All RAND AUTN #i. Out_Src(RAND, AUTN)@i
//         ==> (Ex #j. Src(RAND, AUTN)@j & j < i)
//         | (Ex #j. KU(RAND)@j & j < i)
//         | (Ex #j. KU(AUTN)@j & j < i)
//         | (Ex #j #k . KU(AUTN)@j & j < i
//                     & KU(RAND)@k & k < i)
//     "

//  lemma test_lemma:
//     " /* It cannot be that a  */
//     not(
//         Ex S k #i #j.
//             /* client has set up a session key 'k' with a server'S' */
//             SessKeyC(S, k) @ #i
//             /* and the adversary knows 'k' */
//         & K(k) @ #j
//             /* without having performed a long-term key reveal on 'S'. */
//         & not(Ex #r. LtkReveal(S) @ r)
//     )
//     "

//  lemma message_secrecy:
//    "
//    not(
//       Ex A B #i #j.
//          Asak @ #i & Bsak @ #j
//          & DY(sak) @ #j
//       & not(Ex #r. SessionRevealA(A) | SessionRevealB(B) @ r)
//       | (Ex #r. CakReveal(A) | CakReveal(B))
//    )
//    "

end
