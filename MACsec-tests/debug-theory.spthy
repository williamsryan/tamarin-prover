theory MACsec_Debug
begin

section{* Tester for MACsec stuff. *}

/*
 * Protocol:	MACsec
 * Modeler: 	Ryan Williams
 * Date: 	    May 2023
 *
 * Status: 	    In-progress
 */

 builtins: hashing, asymmetric-encryption, diffie-hellman, signing

 functions: h1/2 // Define a hash function, h1, that takes two parameters and is one-way.

 /*
  * Simple protocol example with just two messages.
  * Written in Alice-and-Bob notation.
  *
  * Client generates a fresh symmettric key, k, and encrypts with pulic key, pkS (from server, S).
  *
  * C -> S: aenc(k, pkS)   :: Asymmetric encryption: sending key to server.
  * C <- S: h(k)           :: Server confirms by sending hash of key back to client.
  *
  */

  /*
   * Protocol and environment are modeled using multiset rewriting rules.
   * Rules operate on system state expressed as a multiset (i.e., a bag) of facts.
   * These facts are predicates that store state information.
   * 
   * Rules have a premise and conclusion separated by -->.
   * Executing the rule requires that all facts in the premise are present in
   * the current state, and the facts in the conclusion will be added to the state.
   *
   * Rules are essentially state transitions.
   *
   */

   // Registration of public key.
   rule Register_pk:
        [ Fr(~ltk) ] // State (called premise): Fr fact is a built-in fact that denotes a freshly-generated name.
    -->
        [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]   // Can transition to these states (conclusion).
    
   // Variable types:
   // ~x denotes x:fresh
   // $x denotes x:pub
   // #i denotes i:temporal
   // m denotes m:msg

   // Adversary model allows someone to read a public-key db entry and send it
   // to the network using built-in fact Out, which denotes sending a message
   // to the network. 
   rule Get_pk:
        [ !Pk(A, pubkey) ]
    -->
        [ Out(pubkey) ]
    
    
    // Model the Alice-and-Bob protocol itself.
    // Start a new thread executing client role, choosing
    // the server non-deterministically.
    rule Client_1:
        [ Fr(~k) // Choose fresh key.
        , !Pk($S, pkS) // Lookup public-key of server.
        ]
    -->
        [ Client_1( $S, ~k ) // Store the server and key.
        , Out( aenc(~k, pkS) ) // Send the encrypted session key to server.
        ]
    
    rule Client_2:
        [ Client_1(S, k)   // Retrieve server and session key from previous step.
        , In( h(k) )       // Receive hashed session key from network.
        ]
    --[ SessKeyC( S, k ) ]-> // State that the session key 'k'.
        []                     // was setup with server 'S'.

    // A server thread answering in one-step to a session-key setup request from
    // some client.
    rule Serv_1:
        [ !Ltk($S, ~ltkS)                             // lookup the private-key.
        , In( request )                               // receive a request.
        ]
    --[ AnswerRequest($S, adec(request, ~ltkS)) ]-> // Explanation below
        [ Out( h(adec(request, ~ltkS)) ) ]            // Return the hash of the
                                                    // decrypted request.
    
    /* 
     * Here, the first rule models the client sending its message, while the second rule models it receiving a response.
     * The third rule models the server, both receiving the message and responding in one single rule.
     */

     /*
      * Next, security properties are defined over traces of the action facts of a protocol execution.
      *
      * Properties to be evaluated are denoted by lemmas.
      *
      * The first of these is on the secrecy of session key secrecy from the client point of view.
      * The lemma Client_session_key_secrecy says that it cannot be that a client has set up a session
      * key k with a server S and the adversary learned that k unless the adversary performed
      * a long-term key reveal on the server S.
      */

      lemma Client_session_key_secrecy:
        " /* It cannot be that a  */
            not(
                Ex S k #i #j.
                /* client has set up a session key 'k' with a server 'S' */
                SessKeyC(S, k) @ #i
                /* and the adversary knows 'k' */
                & K(k) @ #j
                /* without having performed a long-term key reveal on 'S'. */
                & not(Ex #r. LtkReveal(S) @ r)
            )
        "

end