theory MACsec_Debug
begin

section{* Tester for MACsec stuff. *}

/*
 *
 * Protocol:	MACsec
 *
 * Based on:    Component-Based Formal Analysis of 5G-AKA:
 *              Channel Assumptions and Session Confusion
 *
 * Channels:    TODO
 *
 * Functions:   TODO
 *
 * Modeler: 	Ryan Williams
 * Date: 	    May 2023
 *
 * Status: 	    DEVELOPMENTAL
 *
 */

 builtins:
    multiset,
    symmetric-encryption

 functions:
    h1/2,   // Define a hash function, h1, that takes two parameters and is one-way.
    KDF/3,  // KDF function.
    MAC/2   // MAC function.


 // Initialisation rule.
 rule preconfigure:
    let
    PSK = ~CAK,
    ICK = KDF(0, 'ick', ~CAK)
    in
    [ Fr(~CAK) ]
    --[ preconfigure(~CAK) ]->
    [ !Cak($A, PSK), !Cak($B, PSK), !Ick($A, ICK), !Ick($B, ICK) ]

 rule sak_distribution:
    let
    nonce = ~nonce,
    ntag = MAC(~nonce, ICK) // Verify this later.
    in
    [ Fr(~nonce) ]
    -->
    [ !Ntag(MAC(~nonce, !Aick)), !Asak(KDF(~nonce, 'sak', ~CAK)), Out(!Ntag) ]

 // Key distribution rule.
//  rule ks_sak_init:
//     [ Anonce(Fr(~nonce)) ]
//     -->
//     [ ASAK(KDF(~nonce, "sak", ~CAK)), Out(~nonce) ]

//  rule ks_sak_init_reply:
//     [ Bnonce(In(~nonce)) ]
//     -->
//     [ BSAK(KDF(~nonce, "sak", ~CAK)), Out(~nonce) ]

//  rule send_sec:
//     let
//     m = "hello",
//     enc_txt = senc(ASAK, m)
//     in
//     [ Send(A, B, enc_txt) ]
//     -->
//     [ Out(enc_txt) ]

 // This is a standard, secure channel abstraction, as previously used in work 
 // by Basin, Radomirovic, and Schmid: Modeling Human Errors in Security Protocols
 // (CSF 2016)
 // Normal Send Secure and Receive Secure rules.
 // Model: "normal channels"
//  rule send_secure:
//     [F_SndS(<channelname, SendType, ReceiveType>, A, B, m)]
//     --[SendSecure(channelname, A, B, m)]->
//     [Sec(<channelname, SendType, ReceiveType>, A, B, m)]

//  rule receive_secure:
//     [Sec(<channelname, SendType, ReceiveType>, A, B, m)]
//     --[ReceiveSecure(channelname, A, B, m)]->
//     [F_RcvS(<channelname, SendType, ReceiveType>, A, B, m)]

 // Holds.
//  lemma rand_autn_src [sources]:
//     " All RAND AUTN #i. Out_Src(RAND, AUTN)@i
//         ==> (Ex #j. Src(RAND, AUTN)@j & j < i)
//         | (Ex #j. KU(RAND)@j & j < i)
//         | (Ex #j. KU(AUTN)@j & j < i)
//         | (Ex #j #k . KU(AUTN)@j & j < i
//                     & KU(RAND)@k & k < i)
//     "

//  lemma test_lemma:
//     " /* It cannot be that a  */
//     not(
//         Ex S k #i #j.
//             /* client has set up a session key 'k' with a server'S' */
//             SessKeyC(S, k) @ #i
//             /* and the adversary knows 'k' */
//         & K(k) @ #j
//             /* without having performed a long-term key reveal on 'S'. */
//         & not(Ex #r. LtkReveal(S) @ r)
//     )
//     "

end
